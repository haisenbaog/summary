1. Dubbo概述：
	是一个分布式服务框架，提供高性能和透明化的rpc远程服务调用方案，以及服务治理方案。
	远程调用：封装了基于长连接的NIO框架，以请求--响应的模式交换信息。
	自动发现：基于注册中心目录服务，使服务消费方能动态获取服务地址列表，使服务提供方能平滑的添加和减少机器。
	集群容错：提供软负载均衡和容错机制。

2. dubbo的架构

	节点角色说明：
	Provider: 暴露服务的服务提供方。
	Consumer: 调用远程服务的服务消费方。
	Registry: 服务注册与发现的注册中心。
	Monitor: 统计服务的调用次调和调用时间的监控中心。
	Container: 服务运行容器

	调用关系说明：
	0. 服务容器负责启动，加载，运行服务提供者。
	1. 服务提供者在启动时，向注册中心注册自己提供的服务。
	2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
	3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
	4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
	5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

3. 注册中心：
	流程：
	1.服务提供者启动时向/dubbo/com.foo.BarService/providers目录下写入URL
	2.服务消费者启动时订阅/dubbo/com.foo.BarService/providers目录下的URL向/dubbo/com.foo.BarService/consumers目录下写入自己的URL
	3.监控中心启动时订阅/dubbo/com.foo.BarService目录下的所有提供者和消费者URL
	注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
	注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表

	Dubbo在安全机制方面是如何解决:
	Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。

	Dubbo有些哪些注册中心:
	Multicast注册中心： Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；
	Zookeeper注册中心： 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更；
	redis注册中心： 基于redis实现，采用key/Map存储，住key存储服务名和类型，Map中key存储服务URL，value服务过期时间。基于redis的发布/订阅模式通知数据变更

4. Dubbo集群提供了哪些负载均衡策略？
	Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；
	RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题；
	LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求；	ConstantHashLoadBalance:一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；缺省时为Random随机调用。

5. Dubbo的集群容错方案有哪些？
	Failover Cluster（默认集群容错方案）:失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。
	Failfast Cluster:快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
	Failsafe Cluster:失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
	Failback Cluster:失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
	Forking Cluster:并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2"来设置最大并行数。
	Broadcast Cluster:广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。

6. Dubbo支持哪些协议，每种协议的应用场景，优缺点？

	dubbo：单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化。	http：基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用。
	redis：基于redis实现的RPC协议。	rmi：采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞。	webservice：基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用	hessian：集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。

7. Dubbo使用的是什么通信框架?
	默认使用NIO Netty框架。

8. Dubbo支持哪些序列化方式？
	默认使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。

9. Dubbo超时时间

	设置方式：
	1.服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。	2.服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。

	服务调用超时问题怎么解决:
	dubbo在调用服务不成功时，默认是会重试两次的。

10.Dubbo和Spring Cloud
	关系:	Dubbo是SOA时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而SpringCloud诞生于微服务架构时代，考虑的是微服务治理的方方面面另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态

	区别:
	最大的区别：Dubbo底层是使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC通信。	而SpringCloud是基于Http协议+Rest接口调用远程过程的通信，相对来说，Http请求会有更大的报文，占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。